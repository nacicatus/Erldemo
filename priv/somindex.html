<!DOCTYPE html>
<html>
<body style="margin:0; overflow:hidden; background:black;">
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let time = 0;
const ws = new WebSocket("ws://" + location.host + "/ws");
ws.onmessage = e => { const d = JSON.parse(e.data); time = d.t * 0.001; };

// --- Shader ---
const vs = `attribute vec2 position; void main() { gl_Position = vec4(position,0,1); }`;
const fs = `
precision highp float;
uniform float u_time;
uniform vec2 u_res;
void main() {
  vec2 uv = (gl_FragCoord.xy / u_res) * 2.0 - 1.0;
  uv.x *= u_res.x / u_res.y;
  float c = 0.5 + 0.5*sin(u_time + length(uv)*10.0);
  gl_FragColor = vec4(vec3(c),1.0);
}
`;

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error("Shader error:", gl.getShaderInfoLog(s));
    }
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);

const pos = gl.getAttribLocation(prog,"position");
gl.enableVertexAttribArray(pos);
gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);

const u_time = gl.getUniformLocation(prog,"u_time");
const u_res  = gl.getUniformLocation(prog,"u_res");

function render() {
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.uniform1f(u_time,time);
    gl.uniform2f(u_res,canvas.width,canvas.height);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
