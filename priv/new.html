<!DOCTYPE html>
<html>
<body style="margin:0; overflow:hidden; background:black;">
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- WebSocket ---
const ws = new WebSocket("ws://" + location.host + "/ws");
let time = 0;

ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    time = data.t * 0.001;
};

// --- Shader setup ---
const vs = `
attribute vec2 position;
void main() {
    gl_Position = vec4(position, 0.0, 1.0);
}
`;

const fs = `
precision highp float;
uniform float u_time;
uniform vec2 u_res;

// Signed distance sphere
float sphere(vec3 p, float r) {
    return length(p) - r;
}

// Scene
float map(vec3 p) {
    p.x += sin(u_time) * 0.5;
    return sphere(p, 1.0);
}

// Raymarch
float march(vec3 ro, vec3 rd) {
    float d = 0.0;
    for(int i=0;i<64;i++) {
        vec3 p = ro + rd * d;
        float dist = map(p);
        if(dist < 0.001) return d;
        d += dist;
        if(d > 20.0) break;
    }
    return -1.0;
}

void main() {
    vec2 uv = (gl_FragCoord.xy / u_res) * 2.0 - 1.0;
    uv.x *= u_res.x / u_res.y;

    vec3 ro = vec3(0.0, 0.0, -3.0);
    vec3 rd = normalize(vec3(uv, 1.0));
    float col = 0.5 + 0.5*sin(u_time + length(uv) * 10.0);
    float d = march(ro, rd);

    #vec3 col = vec3(0.0);

    if(d > 0.0) {
        col = vec3(0.2, 0.6, 1.0) * (1.0 - d * 0.1);
    }

    gl_FragColor = vec4(vec3(col), 1.0);
}
`;

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

// Fullscreen quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

const pos = gl.getAttribLocation(prog, "position");
gl.enableVertexAttribArray(pos);
gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

const u_time = gl.getUniformLocation(prog, "u_time");
const u_res = gl.getUniformLocation(prog, "u_res");

function render() {
    gl.viewport(0,0,canvas.width,canvas.height);

    gl.uniform1f(u_time, time * 0.001);
    gl.uniform2f(u_res, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
